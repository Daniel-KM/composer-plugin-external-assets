#!/usr/bin/env php
<?php
/**
 * CLI tool to install external assets for packages.
 *
 * For packages installed via git clone, external assets (js, css, etc.) defined
 * in composer.json are not downloaded automatically by Composer. This script
 * reads the package composer.json and downloads the assets.
 *
 * Note: Packages installed via `composer require` have their assets downloaded
 * automatically by the daniel-km/external-assets Composer plugin.
 *
 * Usage:
 *   php bin/external-assets /path/to/package
 *
 * Examples:
 *   php bin/external-assets /var/www/project/modules/MyModule
 *   php bin/external-assets --force /var/www/project/modules/MyModule
 *
 * Options:
 *   --force     Re-download even if assets already exist
 *   --help      Show this help message
 */

declare(strict_types=1);

namespace DanielKm\ExternalAssets;

// Handle autoload - try different locations for standalone usage
$autoloadPaths = [
    __DIR__ . '/../vendor/autoload.php',        // Installed via composer as standalone
    __DIR__ . '/../../../autoload.php',          // Installed as a dependency
];

$autoloaded = false;
foreach ($autoloadPaths as $autoloadPath) {
    if (file_exists($autoloadPath)) {
        require $autoloadPath;
        $autoloaded = true;
        break;
    }
}

if (!$autoloaded) {
    // Minimal inline implementation for when running without composer
    require_once __DIR__ . '/../src/ExternalAssetsPlugin.php';
}

// Parse arguments
$args = array_slice($argv, 1);
$force = false;
$help = false;
$paths = [];

foreach ($args as $arg) {
    if ($arg === '--force') {
        $force = true;
    } elseif ($arg === '--help' || $arg === '-h') {
        $help = true;
    } elseif (strpos($arg, '--') !== 0) {
        $paths[] = $arg;
    }
}

if ($help || empty($paths)) {
    echo <<<HELP
External Assets Installer

Install external assets (JS, CSS, etc.) defined in a package's composer.json
"extra.external-assets" section.

Usage:
  php bin/external-assets [options] <path> [<path2> ...]

Arguments:
  path              Path to package directory

Options:
  --force           Re-download even if assets already exist
  --help, -h        Show this help message

Examples:
  php bin/external-assets /var/www/project/modules/MyModule
  php bin/external-assets --force /var/www/project/modules/Common

The script reads each directory's composer.json and downloads the assets
defined in the "extra.external-assets" section:

  "extra": {
      "external-assets": {
          "asset/vendor/lib/file.min.js": "https://example.com/file.min.js",
          "asset/vendor/lib/": "https://example.com/archive.zip"
      }
  }


HELP;
    exit($help ? 0 : 1);
}

// Create a simple CLI logger
$logger = new class {
    public function info(string $message): void
    {
        echo "[INFO] $message\n";
    }
    public function error(string $message): void
    {
        echo "[ERROR] $message\n";
    }
    public function write(string $message): void
    {
        echo "$message\n";
    }
    public function writeError(string $message): void
    {
        fwrite(STDERR, "$message\n");
    }
};

// Process each path
$totalInstalled = 0;
$totalSkipped = 0;
$totalFailed = 0;

foreach ($paths as $path) {
    $path = realpath($path);
    if (!$path || !is_dir($path)) {
        $logger->writeError("Error: '$path' is not a valid directory.");
        $totalFailed++;
        continue;
    }

    $composerJson = $path . '/composer.json';
    if (!file_exists($composerJson)) {
        $logger->writeError("Warning: No composer.json found in $path");
        continue;
    }

    $json = json_decode(file_get_contents($composerJson), true);
    if (empty($json['extra']['external-assets'])) {
        $logger->info("No external-assets defined in " . basename($path));
        continue;
    }

    $logger->write("Processing " . basename($path) . "...");

    $success = true;
    foreach ($json['extra']['external-assets'] as $destination => $url) {
        $destPath = $path . '/' . ltrim($destination, '/');
        $isDirectory = substr($destination, -1) === '/';
        $isArchive = (bool) preg_match('/\.(zip|tar\.gz|tgz)$/i', $url);

        // Check if asset exists (and skip if not forcing)
        if (!$force) {
            $exists = false;
            if ($isDirectory) {
                if (is_dir($destPath)) {
                    $entries = array_diff(scandir($destPath), ['.', '..']);
                    $exists = count($entries) > 0;
                }
            } else {
                $exists = file_exists($destPath);
            }

            if ($exists) {
                $logger->info("  Asset exists: $destination (use --force to re-download)");
                continue;
            }
        } else {
            // Force mode: remove existing assets
            if ($isDirectory && is_dir($destPath)) {
                $logger->info("  Removing $destination for re-download");
                removeDirectory($destPath);
            } elseif (file_exists($destPath)) {
                $logger->info("  Removing $destination for re-download");
                unlink($destPath);
            }
        }

        $logger->info("  Downloading " . basename($url) . " -> $destination");

        try {
            if ($isDirectory && $isArchive) {
                downloadAndExtract($url, $destPath);
            } elseif ($isDirectory) {
                downloadFile($url, $destPath . basename($url));
            } else {
                downloadFile($url, $destPath);
            }
        } catch (\Exception $e) {
            $logger->error("  Failed: " . $e->getMessage());
            $success = false;
        }
    }

    if ($success) {
        $totalInstalled++;
    } else {
        $totalFailed++;
    }
}

$logger->write("\nDone. Processed: $totalInstalled, Failed: $totalFailed");

exit($totalFailed > 0 ? 1 : 0);

// Helper functions

function downloadFile(string $url, string $destPath): void
{
    $destDir = dirname($destPath);
    if (!is_dir($destDir)) {
        mkdir($destDir, 0755, true);
    }

    $content = fetchUrl($url);
    file_put_contents($destPath, $content);
}

function downloadAndExtract(string $url, string $destPath): void
{
    $tempFile = sys_get_temp_dir() . '/' . basename($url);
    $tempDir = sys_get_temp_dir() . '/external_extract_' . uniqid();

    mkdir($tempDir, 0755, true);

    try {
        $content = fetchUrl($url);
        file_put_contents($tempFile, $content);

        if (preg_match('/\.zip$/i', $url)) {
            extractZip($tempFile, $tempDir);
        } elseif (preg_match('/\.(tar\.gz|tgz)$/i', $url)) {
            extractTarGz($tempFile, $tempDir);
        }

        @unlink($tempFile);

        // Check if archive has a single root directory and strip it
        $sourceDir = getArchiveSourceDir($tempDir);

        // Move contents to destination
        if (!is_dir($destPath)) {
            mkdir($destPath, 0755, true);
        }
        moveDirectoryContents($sourceDir, $destPath);

        // Cleanup temp directory
        removeDirectory($tempDir);
    } catch (\Exception $e) {
        @unlink($tempFile);
        removeDirectory($tempDir);
        throw $e;
    }
}

function fetchUrl(string $url): string
{
    $context = stream_context_create([
        'http' => [
            'method' => 'GET',
            'header' => "User-Agent: external-assets/1.0\r\n",
            'follow_location' => true,
            'timeout' => 60,
        ],
        'ssl' => [
            'verify_peer' => true,
            'verify_peer_name' => true,
        ],
    ]);

    $content = @file_get_contents($url, false, $context);
    if ($content === false) {
        throw new \RuntimeException('Failed to download: ' . $url);
    }

    return $content;
}

function extractZip(string $zipFile, string $destDir): void
{
    // Try command line first
    $command = sprintf(
        'unzip -o -q %s -d %s 2>&1',
        escapeshellarg($zipFile),
        escapeshellarg($destDir)
    );
    exec($command, $output, $exitCode);

    if ($exitCode === 0) {
        return;
    }

    // Fallback to ZipArchive
    if (!class_exists('ZipArchive')) {
        throw new \RuntimeException('Cannot extract zip: unzip command failed and ZipArchive not available');
    }

    $zip = new \ZipArchive();
    if ($zip->open($zipFile) !== true) {
        throw new \RuntimeException('Failed to open zip archive');
    }
    $zip->extractTo($destDir);
    $zip->close();
}

function extractTarGz(string $tarFile, string $destDir): void
{
    // Try command line first
    $command = sprintf(
        'tar -xzf %s -C %s 2>&1',
        escapeshellarg($tarFile),
        escapeshellarg($destDir)
    );
    exec($command, $output, $exitCode);

    if ($exitCode === 0) {
        return;
    }

    // Fallback to PharData
    $phar = new \PharData($tarFile);
    $phar->extractTo($destDir);
}

function getArchiveSourceDir(string $tempDir): string
{
    $entries = array_diff(scandir($tempDir), ['.', '..']);

    // If single entry and it's a directory, use it as source (strip root)
    if (count($entries) === 1) {
        $entry = reset($entries);
        $entryPath = $tempDir . '/' . $entry;
        if (is_dir($entryPath)) {
            return $entryPath;
        }
    }

    return $tempDir;
}

function moveDirectoryContents(string $source, string $dest): void
{
    $entries = array_diff(scandir($source), ['.', '..']);

    foreach ($entries as $entry) {
        $srcPath = $source . '/' . $entry;
        $dstPath = $dest . '/' . $entry;

        if (is_dir($srcPath)) {
            if (!is_dir($dstPath)) {
                mkdir($dstPath, 0755, true);
            }
            moveDirectoryContents($srcPath, $dstPath);
            @rmdir($srcPath);
        } else {
            if (file_exists($dstPath)) {
                @unlink($dstPath);
            }
            rename($srcPath, $dstPath);
        }
    }
}

function removeDirectory(string $dir): void
{
    if (!is_dir($dir)) {
        return;
    }

    $entries = array_diff(scandir($dir), ['.', '..']);
    foreach ($entries as $entry) {
        $path = $dir . '/' . $entry;
        if (is_dir($path)) {
            removeDirectory($path);
        } else {
            @unlink($path);
        }
    }
    @rmdir($dir);
}
